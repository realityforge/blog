<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://www.google.com/2005/gml/b" xmlns:data="http://www.google.com/2005/gml/data" xmlns:expr="http://www.google.com/2005/gml/expr"><head>

<title>Kickin' the Darkness: Concretizing Static Typing Metadata</title>
</head>
<body>
<h2 class="date-header">Monday, February 11, 2008</h2>
<h3 class="post-title entry-title">
<a href="http://blog.kickin-the-darkness.com/2008/02/concretizing-static-typing-metadata.html">Concretizing Static Typing Metadata</a>
</h3>
<p>Well, that's a pretentious title, doncha think?<br><br>Steve Yegge writes in <a title="Portrait of a Noob" href="http://steve-yegge.blogspot.com/2008/02/portrait-of-n00b.html" id="msvv">Portrait of a Noob</a>
that static typing is effectively meta-data ("we also know that static
types are just metadata"), like comments, and so isn't strictly
required for the compilation and execution of software. He's right in a
limited context. If static typing is being used for nothing more than
ensuring "type matching", and really doesn't add anything beyond that,
then it is effectively just a stronger form of commenting, with the
compiler acting in the role of object compatibility inspector.<br><br>This
does get at why the argument for "type safety" has never achieved much
success as a compelling reason for using a strongly typed language.
Merely making sure your objects are compatible is a good thing, but it
does constrain flexibility, extensibility, and adds type management
overhead (to the programmer).<br><br>If strong typing is going to be
seriously valuable it has to do more than merely ensure type safety, it
needs to actually add concrete information to the software.<br><br>Take
a programming language like Ada, considered one of the paragons of
strongly typed programming languages. It does all the type safety
stuff, and Ada advocates are more than happy to promote that as one of
its great virtues for creating and delivering reliable, safety-critical
software. All true, but obviously type safety, accompanied by its
supporting syntax and semantics, was not sufficiently compelling to
drive any significant adoption outside the defense and aerospace
industries (and in those fields, of course, much of the initial impetus
was mandate-driven anyway).<br><br>What most of the Ada programming language advocates overlooked was the productivity gain possible by the language's <i>specific implementation </i>of strong typing. When its advocates talked about strong typing aiding productivity, it was nearly always in terms of <i>error avoidance</i>. Again, true, and a good thing, but hardly sexy. After all, how many programmers are going to <a title="concede that they write buggy code" href="http://blog.kickin-the-darkness.com/2007/09/confessions-of-terrible-programmer.html" id="l3cs">willingly admit that they write buggy code</a> and that maybe they should look into using a programming language that would help them avoid errors?<br>     <br>I went into some detail about this in <a title="The Fundamental Theory of Ada" href="http://blog.kickin-the-darkness.com/2007/08/fundamental-theory-of-ada.html" id="t4lr">The Fundamental Theory of Ada</a>,
describing how the specifics of Ada's "type model" allows the Ada
programmer to implicitly embed scads of additional information <i>with no effort beyond that of defining a type</i>.
The language specifies all the additional programmatic information
directly accessible to the programmer pertaining to that type. In a
sense, user-defined type definitions implicitly declare an associated
class instance with information relevant to that type. Here's an
excerpt from <a title="Ada" href="http://blog.kickin-the-darkness.com/2007/08/fundamental-theory-of-ada.html" id="r3yr">Ada</a>:<br></p><blockquote><code>   type Speed_Range is range 0 .. 1000;</code><br><br>With nothing more than a reference to an object of that type:<br><br><code>  Speed : Speed_Range;</code><br><br>One
can know its minimum value (Speed_Range'First), maximum value
(Speed_Range'Last), the minimum number of bits needed to represent all
possible values of the type (Speed_Range'Size), the actual number of
bits representing a variable of that type (Speed'Size, which is often
larger than the type size since objects almost always occupy a whole
number of bytes), the number of characters needed to represent the
longest possible string representation of values of that type
(Speed_Range'Width), etc. You can convert values to and from strings
(Speed_Range'Image, Speed_Range'Value), do min/max comparisons
(Speed_Range'Min(100, Speed), Speed_Range'Max(Current_Max, Speed)), and
use the type as a loop controller ("for S in Speed_Range loop" and
"while S in Speed_Range loop"), and more. And <i>none</i> of this information needs to be explicitly programmed by a developer, it is <i>all</i> implicitly provided by the mere definition of the type.</blockquote>
This is where strong typing is far more than disposable metadata, like
comments. This "aggressive" approach to strong typing, whether in Ada
or a similarly conceived programming language, "concretizes" the
metadata into practical use to not merely aid error avoidance, but to
actively <i>increase </i>programmer productivity.

</body></html>